/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.2.1.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import {
  Actor,
  HttpAgent,
  type HttpAgentOptions,
  type ActorConfig,
  type Agent,
  type ActorSubclass,
} from "@icp-sdk/core/agent"
import type { Principal } from "@icp-sdk/core/principal"
import { idlFactory, type _SERVICE } from "./declarations/backend.did"
export interface Some<T> {
  __kind__: "Some"
  value: T
}
export interface None {
  __kind__: "None"
}
export type Option<T> = Some<T> | None
function some<T>(value: T): Some<T> {
  return {
    __kind__: "Some",
    value: value,
  }
}
function none(): None {
  return {
    __kind__: "None",
  }
}
function isNone<T>(option: Option<T>): option is None {
  return option.__kind__ === "None"
}
function isSome<T>(option: Option<T>): option is Some<T> {
  return option.__kind__ === "Some"
}
function unwrap<T>(option: Option<T>): T {
  if (isNone(option)) {
    throw new Error("unwrap: none")
  }
  return option.value
}
function candid_some<T>(value: T): [T] {
  return [value]
}
function candid_none<T>(): [] {
  return []
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
  return arg == null ? undefined : arg
}
export interface backendInterface {
  get_counter(): Promise<bigint>
  get_message(): Promise<string | null>
  /**
   * Query methods (fast, read-only)
   */
  greet(arg0: string): Promise<string>
  increment(): Promise<bigint>
  /**
   * Update methods (slower, can modify state)
   */
  set_message(arg0: string): Promise<void>
}
export class Backend implements backendInterface {
  constructor(private actor: ActorSubclass<_SERVICE>) {}
  async get_counter(): Promise<bigint> {
    const result = await this.actor.get_counter()
    return result
  }
  async get_message(): Promise<string | null> {
    const result = await this.actor.get_message()
    return from_candid_opt_n1(result)
  }
  async greet(arg0: string): Promise<string> {
    const result = await this.actor.greet(arg0)
    return result
  }
  async increment(): Promise<bigint> {
    const result = await this.actor.increment()
    return result
  }
  async set_message(arg0: string): Promise<void> {
    const result = await this.actor.set_message(arg0)
    return result
  }
}
function from_candid_opt_n1(value: [] | [string]): string | null {
  return value.length === 0 ? null : value[0]
}
export interface CreateActorOptions {
  agent?: Agent
  agentOptions?: HttpAgentOptions
  actorOptions?: ActorConfig
}
export function createActor(
  canisterId: string,
  options: CreateActorOptions = {}
): Backend {
  const agent =
    options.agent ||
    HttpAgent.createSync({
      ...options.agentOptions,
    })
  if (options.agent && options.agentOptions) {
    console.warn(
      "Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."
    )
  }
  const actor = Actor.createActor<_SERVICE>(idlFactory, {
    agent,
    canisterId: canisterId,
    ...options.actorOptions,
  })
  return new Backend(actor)
}
