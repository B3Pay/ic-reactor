/**
 * Query hook generator
 *
 * Generates createQuery-based hooks for canister query methods.
 */

import type { MethodInfo, ReactorConfig } from "../types.js"
import {
  toPascalCase,
  getHookExportName,
  getReactHookName,
  getReactorName,
  getServiceTypeName,
} from "../utils/naming.js"

export interface QueryHookOptions {
  canisterName: string
  method: MethodInfo
  config: ReactorConfig
}

/**
 * Generate a query hook file content
 */
export function generateQueryHook(options: QueryHookOptions): string {
  const { canisterName, method } = options

  const pascalMethod = toPascalCase(method.name)
  const reactorName = getReactorName(canisterName)
  const serviceName = getServiceTypeName(canisterName)
  const hookExportName = getHookExportName(method.name, "query")
  const reactHookName = getReactHookName(method.name, "query")

  if (method.hasArgs) {
    // Query with arguments - use factory pattern
    return `/**
 * Query Hook: ${method.name}
 *
 * Auto-generated by @ic-reactor/cli
 * This hook wraps the ${method.name} query method.
 *
 * @example
 * // With the factory (for dynamic args)
 * const query = ${hookExportName}([arg1, arg2])
 * const { data } = query.useQuery()
 *
 * // Or use the hook directly
 * const { data } = ${reactHookName}([arg1, arg2])
 */

import { createQueryFactory } from "@ic-reactor/react"
import { ${reactorName}, type ${serviceName} } from "../reactor"

// ═══════════════════════════════════════════════════════════════════════════
// QUERY FACTORY
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Query factory for ${method.name}
 *
 * Creates a query instance with the provided arguments.
 * Each unique set of args gets its own cached query.
 */
export const ${hookExportName} = createQueryFactory(${reactorName}, {
  functionName: "${method.name}",
  // Customize your query options:
  // staleTime: 5 * 60 * 1000,
  // select: (data) => data,
})

// ═══════════════════════════════════════════════════════════════════════════
// CONVENIENCE HOOK
// ═══════════════════════════════════════════════════════════════════════════

/**
 * React hook for ${method.name}
 *
 * @param args - Arguments to pass to the canister method
 * @param options - Additional React Query options
 */
export function ${reactHookName}(
  args: Parameters<${serviceName}["${method.name}"]>,
  options?: Parameters<ReturnType<typeof ${hookExportName}>["useQuery"]>[0]
) {
  return ${hookExportName}(args).useQuery(options)
}

// ═══════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Fetch ${method.name} directly (for loaders, server components, etc.)
 */
export function fetch${pascalMethod}(args: Parameters<${serviceName}["${method.name}"]>) {
  return ${hookExportName}(args).fetch()
}

/**
 * Invalidate ${method.name} query cache
 */
export function invalidate${pascalMethod}(args: Parameters<${serviceName}["${method.name}"]>) {
  return ${hookExportName}(args).invalidate()
}

/**
 * Get ${method.name} query key (for cache manipulation)
 */
export function get${pascalMethod}QueryKey(args: Parameters<${serviceName}["${method.name}"]>) {
  return ${hookExportName}(args).getQueryKey()
}
`
  } else {
    // Query without arguments - static instance
    return `/**
 * Query Hook: ${method.name}
 *
 * Auto-generated by @ic-reactor/cli
 * This hook wraps the ${method.name} query method.
 *
 * @example
 * // Use the hook
 * const { data, isLoading } = ${reactHookName}()
 *
 * // Or access the query object directly
 * const data = await ${hookExportName}.fetch()
 * ${hookExportName}.invalidate()
 */

import { createQuery } from "@ic-reactor/react"
import { ${reactorName} } from "../reactor"

// ═══════════════════════════════════════════════════════════════════════════
// QUERY INSTANCE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Query for ${method.name}
 *
 * Provides:
 * - .useQuery() - React hook
 * - .fetch() - Direct fetch (for loaders)
 * - .invalidate() - Invalidate cache
 * - .getQueryKey() - Get query key
 * - .getCacheData() - Read from cache
 */
export const ${hookExportName} = createQuery(${reactorName}, {
  functionName: "${method.name}",
  // Customize your query options:
  // staleTime: 5 * 60 * 1000,
  // select: (data) => data,
})

// ═══════════════════════════════════════════════════════════════════════════
// CONVENIENCE EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * React hook for ${method.name}
 */
export const ${reactHookName} = ${hookExportName}.useQuery

/**
 * Fetch ${method.name} directly (for loaders, server components, etc.)
 */
export const fetch${pascalMethod} = ${hookExportName}.fetch

/**
 * Invalidate ${method.name} query cache
 */
export const invalidate${pascalMethod} = ${hookExportName}.invalidate

/**
 * Get ${method.name} query key (for cache manipulation)
 */
export const get${pascalMethod}QueryKey = ${hookExportName}.getQueryKey

/**
 * Get cached data for ${method.name}
 */
export const get${pascalMethod}CacheData = ${hookExportName}.getCacheData
`
  }
}
