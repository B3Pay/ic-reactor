/**
 * Infinite Query hook generator
 *
 * Generates createInfiniteQuery-based hooks for paginated canister methods.
 */

import type { MethodInfo, ReactorConfig } from "../types.js"
import {
  toPascalCase,
  toCamelCase,
  getReactorName,
  getServiceTypeName,
} from "../utils/naming.js"

export interface InfiniteQueryHookOptions {
  canisterName: string
  method: MethodInfo
  config: ReactorConfig
}

/**
 * Generate an infinite query hook file content
 */
export function generateInfiniteQueryHook(
  options: InfiniteQueryHookOptions
): string {
  const { canisterName, method } = options

  const pascalMethod = toPascalCase(method.name)
  const camelMethod = toCamelCase(method.name)
  const reactorName = getReactorName(canisterName)
  const serviceName = getServiceTypeName(canisterName)

  return `/**
 * Infinite Query Hook: ${method.name}
 *
 * Auto-generated by @ic-reactor/cli
 * This hook wraps the ${method.name} method for infinite/paginated queries.
 *
 * ⚠️  CUSTOMIZATION REQUIRED:
 * You need to configure getArgs and getNextPageParam based on your API.
 *
 * @example
 * const {
 *   data,
 *   fetchNextPage,
 *   hasNextPage,
 *   isFetching,
 * } = ${camelMethod}InfiniteQuery.useInfiniteQuery()
 *
 * // Flatten all pages
 * const allItems = data?.pages.flatMap(page => page.items) ?? []
 */

import { createInfiniteQuery } from "@ic-reactor/react"
import { ${reactorName}, type ${serviceName} } from "../reactor"

// ═══════════════════════════════════════════════════════════════════════════
// CURSOR TYPE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Define your pagination cursor type here.
 * Common patterns:
 * - number (offset-based)
 * - string (cursor-based)
 * - { offset: number; limit: number }
 */
type PageCursor = number

// ═══════════════════════════════════════════════════════════════════════════
// INFINITE QUERY INSTANCE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Infinite query for ${method.name}
 *
 * Provides:
 * - .useInfiniteQuery() - React hook with pagination
 * - .fetch() - Fetch first page
 * - .invalidate() - Invalidate all pages
 * - .getQueryKey() - Get query key
 * - .getCacheData() - Read from cache
 */
export const ${camelMethod}InfiniteQuery = createInfiniteQuery(${reactorName}, {
  functionName: "${method.name}",

  // ─────────────────────────────────────────────────────────────────────────
  // PAGINATION CONFIG (CUSTOMIZE THESE)
  // ─────────────────────────────────────────────────────────────────────────

  /**
   * Initial page parameter (e.g., 0 for offset, null for cursor)
   */
  initialPageParam: 0 as PageCursor,

  /**
   * Convert page param to method arguments.
   * Customize this based on your canister API.
   */
  getArgs: (pageParam: PageCursor) => {
    // Example: offset-based pagination
    return [{ offset: pageParam, limit: 10 }] as Parameters<${serviceName}["${method.name}"]>

    // Example: cursor-based pagination
    // return [{ cursor: pageParam, limit: 10 }] as Parameters<${serviceName}["${method.name}"]>
  },

  /**
   * Extract next page param from the last page.
   * Return undefined/null when there are no more pages.
   */
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    // Example: offset-based - return next offset or undefined if no more
    // const items = lastPage.items ?? []
    // if (items.length < 10) return undefined
    // return lastPageParam + 10

    // Example: cursor-based
    // return lastPage.nextCursor ?? undefined

    // Placeholder - customize for your API
    return undefined
  },

  // ─────────────────────────────────────────────────────────────────────────
  // OPTIONAL CONFIG
  // ─────────────────────────────────────────────────────────────────────────

  // Bi-directional scrolling (optional)
  // getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
  //   return firstPageParam > 0 ? firstPageParam - 10 : undefined
  // },

  // Max pages to keep in cache (for memory management)
  // maxPages: 10,

  // How long data stays fresh
  // staleTime: 5 * 60 * 1000,

  // Transform the data
  // select: (data) => ({
  //   pages: data.pages,
  //   pageParams: data.pageParams,
  //   items: data.pages.flatMap(page => page.items),
  // }),
})

// ═══════════════════════════════════════════════════════════════════════════
// CONVENIENCE EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * React hook for paginated ${method.name}
 */
export const use${pascalMethod}InfiniteQuery = ${camelMethod}InfiniteQuery.useInfiniteQuery

/**
 * Fetch first page of ${method.name}
 */
export const fetch${pascalMethod}FirstPage = ${camelMethod}InfiniteQuery.fetch

/**
 * Invalidate all cached pages
 */
export const invalidate${pascalMethod}Pages = ${camelMethod}InfiniteQuery.invalidate
`
}
