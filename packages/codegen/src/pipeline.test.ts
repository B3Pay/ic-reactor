import fs from "node:fs"
import os from "node:os"
import path from "node:path"
import { afterEach, describe, expect, it } from "vitest"
import { runCanisterPipeline } from "./pipeline"

describe("Codegen pipeline", () => {
  const tempDirs: string[] = []

  afterEach(() => {
    for (const dir of tempDirs) {
      fs.rmSync(dir, { recursive: true, force: true })
    }
    tempDirs.length = 0
  })

  function createTempProject() {
    const projectRoot = fs.mkdtempSync(
      path.join(os.tmpdir(), "ic-reactor-codegen-pipeline-")
    )
    tempDirs.push(projectRoot)
    return projectRoot
  }

  function writeDid(projectRoot: string, fileName: string) {
    fs.writeFileSync(
      path.join(projectRoot, fileName),
      `service : {
  greet: (text) -> (text) query;
}`
    )
  }

  it("uses per-canister mode to generate Reactor-based hooks", async () => {
    const projectRoot = createTempProject()
    writeDid(projectRoot, "workflow_engine.did")

    const result = await runCanisterPipeline({
      canisterConfig: {
        name: "workflow_engine",
        didFile: "workflow_engine.did",
        mode: "Reactor",
      },
      projectRoot,
      globalConfig: {
        outDir: "src/declarations",
        clientManagerPath: "../../clients",
      },
    })

    expect(result.success).toBe(true)

    const indexPath = path.join(
      projectRoot,
      "src/declarations/workflow_engine/index.ts"
    )
    const generated = fs.readFileSync(indexPath, "utf-8")

    expect(generated).toContain("new Reactor<WorkflowEngineService>")
    expect(generated).not.toContain("new DisplayReactor<WorkflowEngineService>")
  })

  it("does not overwrite user-modified index.ts on regenerate", async () => {
    const projectRoot = createTempProject()
    writeDid(projectRoot, "backend.did")

    const options = {
      canisterConfig: {
        name: "backend",
        didFile: "backend.did",
      },
      projectRoot,
      globalConfig: {
        outDir: "src/declarations",
        clientManagerPath: "../../clients",
      },
    } as const

    const first = await runCanisterPipeline(options)
    expect(first.success).toBe(true)

    const indexPath = path.join(
      projectRoot,
      "src/declarations/backend/index.ts"
    )
    fs.writeFileSync(
      indexPath,
      `// user custom canister file
export const customBackendIndex = true
`
    )

    const second = await runCanisterPipeline(options)
    expect(second.success).toBe(true)

    const wrapper = fs.readFileSync(indexPath, "utf-8")
    expect(wrapper).toContain("customBackendIndex = true")
    expect(second.files).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          filePath: indexPath,
          skipped: true,
          success: true,
        }),
      ])
    )
  })

  it("overwrites legacy generated index.ts during regeneration", async () => {
    const projectRoot = createTempProject()
    writeDid(projectRoot, "backend.did")

    const canisterOutDir = path.join(projectRoot, "src/declarations/backend")
    fs.mkdirSync(canisterOutDir, { recursive: true })

    // Simulate a generated index.ts content from older versions.
    fs.writeFileSync(
      path.join(canisterOutDir, "index.ts"),
      `import { DisplayReactor, createActorHooks } from "@ic-reactor/react"
import { clientManager } from "../../clients"
import { idlFactory, type _SERVICE } from "./declarations/backend"

export type BackendService = _SERVICE

/**
 * Backend Reactor
 *
 * Auto-generated by @ic-reactor/codegen â€” do not edit.
 * Re-run \`ic-reactor generate\` (or the Vite plugin) to regenerate.
 */
export const backendReactor = new DisplayReactor<BackendService>({
  clientManager,
  idlFactory,
  name: "backend",
})

export const {
  useActorQuery: useBackendQuery,
} = createActorHooks(backendReactor)
`
    )

    const result = await runCanisterPipeline({
      canisterConfig: {
        name: "backend",
        didFile: "backend.did",
      },
      projectRoot,
      globalConfig: {
        outDir: "src/declarations",
        clientManagerPath: "../../clients",
      },
    })

    expect(result.success).toBe(true)

    const indexPath = path.join(canisterOutDir, "index.ts")
    const generated = fs.readFileSync(indexPath, "utf-8")
    expect(generated).toContain("new DisplayReactor<BackendService>")
    expect(generated).toContain("useBackendMutation")
    expect(generated).not.toContain('export * from "./index.generated"')
  })
})
