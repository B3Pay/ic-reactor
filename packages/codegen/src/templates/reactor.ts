/**
 * Reactor file template generator
 *
 * Generates the reactor instance file for a canister.
 * Supports both simple mode (generic hooks) and advanced mode (per-method hooks).
 */

import path from "node:path"
import type { ReactorGeneratorOptions } from "../types.js"
import {
  toPascalCase,
  toCamelCase,
  getReactorName,
  getServiceTypeName,
} from "../naming.js"
import { extractMethods } from "../did.js"

/**
 * Generate the reactor file content
 *
 * @param options - Generator options
 * @returns Generated TypeScript source code
 */
export function generateReactorFile(options: ReactorGeneratorOptions): string {
  const {
    canisterName,
    canisterConfig,
    globalClientManagerPath,
    hasDeclarations = true,
    advanced = false,
    didContent,
  } = options

  const pascalName = toPascalCase(canisterName)
  const reactorName = getReactorName(canisterName)
  const serviceName = getServiceTypeName(canisterName)
  const reactorType =
    canisterConfig.useDisplayReactor !== false ? "DisplayReactor" : "Reactor"

  // Calculate relative path to client manager
  const clientManagerPath =
    canisterConfig.clientManagerPath ??
    globalClientManagerPath ??
    "../../lib/client"

  // Calculate relative path to declarations
  const didFileName = path.basename(canisterConfig.didFile)
  const declarationsPath = `./declarations/${didFileName}`

  if (!hasDeclarations) {
    return generateFallbackReactorFile({
      canisterName,
      pascalName,
      reactorName,
      serviceName,
      reactorType,
      clientManagerPath,
      declarationsPath,
      useDisplayReactor: canisterConfig.useDisplayReactor !== false,
    })
  }

  if (advanced && didContent) {
    return generateAdvancedReactorFile({
      canisterName,
      pascalName,
      reactorName,
      serviceName,
      reactorType,
      clientManagerPath,
      declarationsPath,
      didContent,
      useDisplayReactor: canisterConfig.useDisplayReactor !== false,
    })
  }

  return generateSimpleReactorFile({
    canisterName,
    pascalName,
    reactorName,
    serviceName,
    reactorType,
    clientManagerPath,
    declarationsPath,
    useDisplayReactor: canisterConfig.useDisplayReactor !== false,
  })
}

// ═══════════════════════════════════════════════════════════════════════════
// SIMPLE MODE
// ═══════════════════════════════════════════════════════════════════════════

interface SimpleTemplateVars {
  canisterName: string
  pascalName: string
  reactorName: string
  serviceName: string
  reactorType: string
  clientManagerPath: string
  declarationsPath: string
  useDisplayReactor: boolean
}

function generateSimpleReactorFile(vars: SimpleTemplateVars): string {
  const {
    canisterName,
    pascalName,
    reactorName,
    serviceName,
    reactorType,
    clientManagerPath,
    declarationsPath,
    useDisplayReactor,
  } = vars

  return `/**
 * ${pascalName} Reactor
 *
 * Auto-generated by @ic-reactor/codegen
 * This file provides the shared reactor instance and React hooks for the
 * ${canisterName} canister.
 */

import { ${reactorType}, createActorHooks } from "@ic-reactor/react"
import { clientManager } from "${clientManagerPath}"
import { idlFactory, type _SERVICE } from "${declarationsPath}"

// ═══════════════════════════════════════════════════════════════════════════
// SERVICE TYPE
// ═══════════════════════════════════════════════════════════════════════════

export type ${serviceName} = _SERVICE

// ═══════════════════════════════════════════════════════════════════════════
// REACTOR INSTANCE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * ${pascalName} Reactor with ${useDisplayReactor ? "Display" : "Candid"} type transformations.
 * ${useDisplayReactor ? "Automatically converts bigint → string, Principal → string, etc." : "Uses raw Candid types."}
 */
export const ${reactorName} = new ${reactorType}<${serviceName}>({
  clientManager,
  idlFactory,
  name: "${canisterName}",
})

// ═══════════════════════════════════════════════════════════════════════════
// HOOKS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * React hooks for the ${canisterName} canister.
 */
const {
  useActorQuery: use${pascalName}Query,
  useActorSuspenseQuery: use${pascalName}SuspenseQuery,
  useActorInfiniteQuery: use${pascalName}InfiniteQuery,
  useActorSuspenseInfiniteQuery: use${pascalName}SuspenseInfiniteQuery,
  useActorMutation: use${pascalName}Mutation,
  useActorMethod: use${pascalName}Method,
} = createActorHooks(${reactorName})

export {
  use${pascalName}Query,
  use${pascalName}SuspenseQuery,
  use${pascalName}InfiniteQuery,
  use${pascalName}SuspenseInfiniteQuery,
  use${pascalName}Mutation,
  use${pascalName}Method,
}

// ═══════════════════════════════════════════════════════════════════════════
// RE-EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

export { idlFactory }
`
}

// ═══════════════════════════════════════════════════════════════════════════
// ADVANCED MODE
// ═══════════════════════════════════════════════════════════════════════════

interface AdvancedTemplateVars extends SimpleTemplateVars {
  didContent: string
}

function generateAdvancedReactorFile(vars: AdvancedTemplateVars): string {
  const {
    canisterName,
    pascalName,
    reactorName,
    serviceName,
    reactorType,
    clientManagerPath,
    declarationsPath,
    didContent,
    useDisplayReactor,
  } = vars

  const methods = extractMethods(didContent)

  const hooks = methods.map(({ name, type, hasArgs }) => {
    const pascalMethod = toPascalCase(name)
    const camelMethod = toCamelCase(name)

    if (type === "query") {
      const hook = `
export const use${pascalMethod}Query = (
  args: Parameters<${serviceName}["${name}"]>,
  options?: any
) =>
  useActorQuery({
    functionName: "${name}",
    args,
    ...options,
  })
`
      const staticQuery = !hasArgs
        ? `
export const ${camelMethod}Query = createQuery(${reactorName}, {
  functionName: "${name}",
})
`
        : ""
      return hook + staticQuery
    } else {
      const hook = `
export const use${pascalMethod}Mutation = (
  options?: any
) =>
  useActorMutation({
    functionName: "${name}",
    ...options,
  })
`
      const staticMutation = !hasArgs
        ? `
export const ${camelMethod}Mutation = createMutation(${reactorName}, {
  functionName: "${name}",
})
`
        : ""
      return hook + staticMutation
    }
  })

  return `/**
 * ${pascalName} Reactor (Advanced)
 *
 * Auto-generated by @ic-reactor/codegen
 * This file provides the reactor instance, actor hooks, and per-method hooks
 * for the ${canisterName} canister.
 */

import {
  ${reactorType},
  createActorHooks,
  createAuthHooks,
  createQuery,
  createMutation,
} from "@ic-reactor/react"
import { clientManager } from "${clientManagerPath}"
import { idlFactory, type _SERVICE } from "${declarationsPath}"

// ═══════════════════════════════════════════════════════════════════════════
// SERVICE TYPE
// ═══════════════════════════════════════════════════════════════════════════

type ${serviceName} = _SERVICE

// ═══════════════════════════════════════════════════════════════════════════
// REACTOR INSTANCE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * ${pascalName} Reactor with ${useDisplayReactor ? "Display" : "Candid"} type transformations.
 * ${useDisplayReactor ? "Automatically converts bigint → string, Principal → string, etc." : "Uses raw Candid types."}
 */
export const ${reactorName} = new ${reactorType}<${serviceName}>({
  clientManager,
  idlFactory,
  name: "${canisterName}",
})

// ═══════════════════════════════════════════════════════════════════════════
// ACTOR & AUTH HOOKS
// ═══════════════════════════════════════════════════════════════════════════

export const {
  useActorQuery,
  useActorMutation,
  useActorSuspenseQuery,
  useActorInfiniteQuery,
  useActorSuspenseInfiniteQuery,
  useActorMethod,
} = createActorHooks(${reactorName})

export const use${pascalName}Query = useActorQuery
export const use${pascalName}Mutation = useActorMutation
export const use${pascalName}SuspenseQuery = useActorSuspenseQuery
export const use${pascalName}InfiniteQuery = useActorInfiniteQuery
export const use${pascalName}SuspenseInfiniteQuery = useActorSuspenseInfiniteQuery
export const use${pascalName}Method = useActorMethod

export const { useAuth, useAgentState, useUserPrincipal } = createAuthHooks(
  clientManager
)

// ═══════════════════════════════════════════════════════════════════════════
// PER-METHOD HOOKS
// ═══════════════════════════════════════════════════════════════════════════
${hooks.join("")}

// ═══════════════════════════════════════════════════════════════════════════
// RE-EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

export { idlFactory }
export type { ${serviceName} }
`
}

// ═══════════════════════════════════════════════════════════════════════════
// FALLBACK (NO DECLARATIONS)
// ═══════════════════════════════════════════════════════════════════════════

interface FallbackTemplateVars {
  canisterName: string
  pascalName: string
  reactorName: string
  serviceName: string
  reactorType: string
  clientManagerPath: string
  declarationsPath: string
  useDisplayReactor: boolean
}

function generateFallbackReactorFile(vars: FallbackTemplateVars): string {
  const {
    canisterName,
    pascalName,
    reactorName,
    serviceName,
    reactorType,
    clientManagerPath,
    declarationsPath,
    useDisplayReactor,
  } = vars

  return `/**
 * ${pascalName} Reactor
 *
 * Auto-generated by @ic-reactor/codegen
 * This file provides the shared reactor instance for the ${canisterName} canister.
 *
 * You can customize this file to add global configuration.
 */

import { ${reactorType}, createActorHooks } from "@ic-reactor/react"
import { clientManager } from "${clientManagerPath}"

// ═══════════════════════════════════════════════════════════════════════════
// DECLARATIONS
// ═══════════════════════════════════════════════════════════════════════════

// TODO: Generate proper types by running:
// npx @icp-sdk/bindgen --input <path-to-did> --output ./${canisterName}/declarations

// Then uncomment:
// import { idlFactory, type _SERVICE as ${serviceName} } from "${declarationsPath}"

// Fallback generic type - replace with generated types
type ${serviceName} = Record<string, (...args: unknown[]) => Promise<unknown>>

// You'll need to define idlFactory here or import from declarations
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const idlFactory = ({ IDL }: { IDL: any }) => IDL.Service({})

// ═══════════════════════════════════════════════════════════════════════════
// REACTOR INSTANCE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * ${pascalName} Reactor with ${useDisplayReactor ? "Display" : "Candid"} type transformations.
 * ${useDisplayReactor ? "Automatically converts bigint → string, Principal → string, etc." : "Uses raw Candid types."}
 */
export const ${reactorName} = new ${reactorType}<${serviceName}>({
  clientManager,
  idlFactory,
  name: "${canisterName}",
})

// ═══════════════════════════════════════════════════════════════════════════
// ACTOR HOOKS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Actor hooks for ${canisterName} - use these directly or import method-specific hooks.
 */
export const {
  useActorQuery,
  useActorMutation,
  useActorSuspenseQuery,
  useActorInfiniteQuery,
  useActorSuspenseInfiniteQuery,
  useActorMethod,
} = createActorHooks(${reactorName})

// ═══════════════════════════════════════════════════════════════════════════
// RE-EXPORTS
// ═══════════════════════════════════════════════════════════════════════════

export { idlFactory }
export type { ${serviceName} }
`
}
