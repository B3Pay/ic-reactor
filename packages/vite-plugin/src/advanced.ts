import { Plugin } from "vite"
import fs from "fs"
import path from "path"
import { generate } from "@icp-sdk/bindgen/core"
import { IcReactorPluginOptions } from "./index"

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("")
}

function toCamelCase(str: string): string {
  const pascal = toPascalCase(str)
  return pascal.charAt(0).toLowerCase() + pascal.slice(1)
}

interface MethodInfo {
  name: string
  type: "query" | "mutation"
  hasArgs: boolean
}

function extractMethods(didContent: string): MethodInfo[] {
  // Simple regex to extract method names, types, and args
  // Looks for: name : (...) -> (...) [query]
  const methodRegex =
    /([a-zA-Z0-9_]+)\s*:\s*(?:func\s*)?\(([\s\S]*?)\)\s*->\s*\(([\s\S]*?)\)\s*(query|composite_query)?/g

  const methods: MethodInfo[] = []

  let match
  while ((match = methodRegex.exec(didContent)) !== null) {
    const name = match[1]
    const args = match[2].trim()
    const isQuery = !!match[4]

    methods.push({
      name,
      type: isQuery ? "query" : "mutation",
      hasArgs: args.length > 0,
    })
  }

  return methods
}

function generateAdvancedReactorFile(
  canisterName: string,
  useDisplayReactor: boolean,
  clientManagerPath: string,
  didContent: string
): string {
  const pascalName = toPascalCase(canisterName)
  const camelName = toCamelCase(canisterName)
  const reactorType = useDisplayReactor ? "DisplayReactor" : "Reactor"

  const methods = extractMethods(didContent)

  const hooks = methods.map(({ name, type, hasArgs }) => {
    const pascalMethod = toPascalCase(name)
    const camelMethod = toCamelCase(name)

    if (type === "query") {
      const hook = `
export const use${pascalMethod}Query = (
  args: Parameters<${pascalName}Service["${name}"]>,
  options?: any
) => 
  useActorQuery({
    functionName: "${name}",
    args,
    ...options,
  })
`
      const staticQuery = !hasArgs
        ? `
export const ${camelMethod}Query = createQuery(${camelName}Reactor, {
  functionName: "${name}",
})
`
        : ""
      return hook + staticQuery
    } else {
      const hook = `
export const use${pascalMethod}Mutation = (
  options?: any
) =>
  useActorMutation({
    functionName: "${name}",
    ...options,
  })
`
      const staticMutation = !hasArgs
        ? `
export const ${camelMethod}Mutation = createMutation(${camelName}Reactor, {
  functionName: "${name}",
})
`
        : ""
      return hook + staticMutation
    }
  })

  return `/**
 * AUTO-GENERATED BY @ic-reactor/vite-plugin
 * DO NOT EDIT MANUALLY
 *
 * Canister: ${canisterName}
 * Generated: ${new Date().toISOString()}
 *
 * This file provides type-safe React hooks for interacting with the
 * ${canisterName} canister using ic-reactor.
 */

import {
  ${reactorType},
  createActorHooks,
  createAuthHooks,
  createQuery,
  createMutation,
} from "@ic-reactor/react"

// ═══════════════════════════════════════════════════════════════════════════
// USER-PROVIDED CLIENT MANAGER
// ═══════════════════════════════════════════════════════════════════════════
import { clientManager } from "${clientManagerPath}"

// Import generated declarations from @icp-sdk/bindgen
import {
  idlFactory,
  type _SERVICE,
} from "./declarations/${canisterName}.did"

// ═══════════════════════════════════════════════════════════════════════════
// REACTOR INSTANCE
// ═══════════════════════════════════════════════════════════════════════════
type ${pascalName}Service = _SERVICE

/**
 * ${pascalName} Reactor with ${useDisplayReactor ? "Display" : "Candid"} type transformations.
 * ${useDisplayReactor ? "Automatically converts bigint → string, Principal → string, etc." : "Uses raw Candid types."}
 */
export const ${camelName}Reactor = new ${reactorType}<${pascalName}Service>({
  clientManager,
  idlFactory,
  name: "${canisterName}",
})

// ═══════════════════════════════════════════════════════════════════════════
// ACTOR & AUTH HOOKS
// ═══════════════════════════════════════════════════════════════════════════
export const {
  useActorQuery,
  useActorMutation,
  useActorSuspenseQuery,
  useActorInfiniteQuery,
  useActorSuspenseInfiniteQuery,
  useActorMethod,
} = createActorHooks(${camelName}Reactor)

export const use${pascalName}Query = useActorQuery
export const use${pascalName}Mutation = useActorMutation
export const use${pascalName}SuspenseQuery = useActorSuspenseQuery
export const use${pascalName}InfiniteQuery = useActorInfiniteQuery
export const use${pascalName}SuspenseInfiniteQuery = useActorSuspenseInfiniteQuery
export const use${pascalName}Method = useActorMethod

export const { useAuth, useAgentState, useUserPrincipal } = createAuthHooks(
  clientManager
)

// ═══════════════════════════════════════════════════════════════════════════
// METHOD HOOKS
// ═══════════════════════════════════════════════════════════════════════════
${hooks.join("")}

// ═══════════════════════════════════════════════════════════════════════════
// RE-EXPORTS
// ═══════════════════════════════════════════════════════════════════════════
export { idlFactory }
export type { ${pascalName}Service }
`
}

export function icReactorAdvancedPlugin(
  options: IcReactorPluginOptions
): Plugin {
  const baseOutDir = options.outDir ?? "./src/canisters"

  return {
    name: "ic-reactor-advanced-plugin",
    async buildStart() {
      for (const canister of options.canisters) {
        const outDir = canister.outDir ?? path.join(baseOutDir, canister.name)

        if (!fs.existsSync(outDir)) {
          fs.mkdirSync(outDir, { recursive: true })
        }

        console.log(
          `[ic-reactor] Generating advanced hooks for ${canister.name} from ${canister.didFile}`
        )

        try {
          await generate({
            didFile: canister.didFile,
            outDir,
            output: {
              actor: {
                disabled: true,
              },
              force: true,
            },
          })

          console.log(
            `[ic-reactor] Declarations generated at ${path.join(
              outDir,
              "declarations"
            )}`
          )
        } catch (error) {
          console.error(`[ic-reactor] Failed to generate declarations:`, error)
          continue
        }

        const clientManagerPath =
          canister.clientManagerPath ??
          options.clientManagerPath ??
          "../../lib/client"

        let didContent = ""
        try {
          didContent = fs.readFileSync(canister.didFile, "utf-8")
        } catch (e) {
          console.warn(
            `[ic-reactor] Could not read DID file at ${canister.didFile}, skipping hook generation.`
          )
          continue
        }

        const reactorContent = generateAdvancedReactorFile(
          canister.name,
          canister.useDisplayReactor ?? true,
          clientManagerPath,
          didContent
        )

        const reactorPath = path.join(outDir, "index.ts")
        fs.writeFileSync(reactorPath, reactorContent)

        console.log(
          `[ic-reactor] Advanced reactor hooks generated at ${reactorPath}`
        )
      }
    },
    handleHotUpdate({ file, server }) {
      if (file.endsWith(".did")) {
        const canister = options.canisters.find(
          (c) => path.resolve(c.didFile) === file
        )
        if (canister) {
          console.log(
            `[ic-reactor] Detected change in ${file}, regenerating...`
          )
          server.restart()
        }
      }
    },
  }
}
